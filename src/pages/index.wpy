<template>
  <view class="container">
    <IndexHeader  :titleList.sync="titleList" :selectedItem.sync="activeBar"></IndexHeader>
    <inputNames :personList.sync="personList" :activeBar.sync="activeBar"></inputNames>
    <view class="roundCount">
      <label for="roundPer">每人场数</label>
      <input type="number" name="" id="roundCount" value="{{roundCount}}" @input="changeRoundCount"/>
    </view>
    <button id="btn" @tap="makeGroup">生产对阵表</button>
    <adajustByStep :personList.sync="personList"  :activeBar.sync="activeBar"></adajustByStep>
    <!-- <resultOfNames :personList.sync="personList"></resultOfNames>     -->
  </view>
</template>
<style lang="less" scoped>
@import '../common/common.less';
.roundCount{
    font-size:30rpx;
    background: @bgc-card;
    margin:40rpx 0;
    padding-left:30rpx;
    border-bottom: 2px solid @bgc;
    label{
      width: 150rpx;
      color: @font-side;
      font-weight: lighter;
    }
    label,input{
      display: inline-block;
      height: 60px;
      line-height: 60px;
      vertical-align: middle;
    }
    input{
      width:500rpx;
    }
  }

  #btn{
    margin:40rpx auto;
    width:450rpx;
    height:100rpx;
    line-height: 100rpx;
    vertical-align: middle;
    text-align: center;
  }
</style>

<script>
import wepy from 'wepy'
import { setStorage } from '../common/util'
import { requestTableList } from '../common/common'
import header from '../components/header'
import inputNames from '../components/inputNames'
import adajustByStep from '../components/adajustByStep'
import 'wepy-async-function'
export default class Index extends wepy.page {
  components = {
    IndexHeader: header,
    inputNames: inputNames,
    adajustByStep: adajustByStep
  }
  data={
    personList: [],
    roundCount:4,
    activeBar: '输入报名人员',
    titleList: ['输入报名人员', '调整人员实力']
  }
  watch={
    personList () {
      setStorage('personList', this.personList)
    },
    activeBar(){
      this.personList=this.personList.filter(name=>{
        return name
      })
    }
  }
  onShareAppMessage() {
    return {}
  }
  events={
    upadtaPersonList(newPersonList) {
      this.personList = newPersonList.filter(name=>{
        return name
      })
    }
  }
  methods={
    changeRoundCount(e){
      this.roundCount=e.detail.value
    },
    makeGroup() {
      this.personList=this.personList.filter(name=>{
        return name
      })
      if(!this.roundCount){
        wepy.showModal({
            title: '错误提示',
            content: '场次不能为空',
            mask: true,
            duration: 2000
          })
          return
        }
      if(this.personList.length * this.roundCount % 4){
        wepy.showModal({
            title: '错误提示',
            content: '场次和人数的乘积 不能被4整除 排阵失败！！',
            mask: true,
            duration: 2000
          })
          return
      }
        this.getAgainstTable()
      }
  }
      getAgainstTable= async function() {
        // 由于后端顺序 是由弱到强排列的 所以 先对人员的数组转序
        let reversePersonList = []
        for (let i = this.personList.length - 1; i >= 0; i--) {
          reversePersonList.push(this.personList[i])
        }
        //请求 对阵表
        let groupList=await requestTableList(this.personList.length,this.roundCount)
        //将请求到的 只有数字的对阵表 转换成带人名的 对阵表，并在后面加上 分数 和完成状态
        groupList.forEach((numList,index,groupList)=>{
          this.transformNumToPersonName(numList,reversePersonList)
          groupList[index]=groupList[index].concat([0, 0, 'undone'])
        })
        //完成后保存结果 并跳转到对阵表
        wx.setStorageSync('groupList',groupList)
        wx.showModal({
          title: '友情建议',
          content: `共为您排了${groupList.length}场比赛，如果您的赛时为2小时，建议预定${Math.ceil(groupList.length / 14)}个场地!\rps:每个场地不宜超过14场。`,
          success:()=>{
            wx.switchTab({
              url:'/pages/main'
            })
          }
        })
        
      }
      transformNumToPersonName(numList,nameList){
        numList.forEach((num,index,numList) => {
          numList[index]=nameList[num-1]
        });
      }

}
</script>
